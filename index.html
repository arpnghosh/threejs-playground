<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        #fileInput {
            display: none;
        }
        
        .btn {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .btn:hover {
            background: #555;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 200px;
        }
        
        #status {
            color: #888;
            font-size: 12px;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                Load STL File
            </button>
            <input type="file" id="fileInput" accept=".stl" />
            <span id="status">No file loaded</span>
        </div>
        
        <div id="info">
            <div><strong>Controls:</strong></div>
            <div>• Left click + drag: Rotate</div>
            <div>• Right click + drag: Pan</div>
            <div>• Scroll: Zoom</div>
            <div>• R: Reset view</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let currentMesh = null;
        
        // Initialize Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Grid
            const gridHelper = new THREE.GridHelper(100, 20, 0x444444, 0x444444);
            scene.add(gridHelper);
            
            // Simple orbit controls implementation
            initControls();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Keyboard controls
            document.addEventListener('keydown', onKeyDown);
            
            animate();
        }
        
        // Simple orbit controls
        function initControls() {
            let isMouseDown = false;
            let isRightMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let targetPosition = { x: 0, y: 0, z: 0 };
            
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            function onMouseDown(event) {
                if (event.button === 0) { // Left click
                    isMouseDown = true;
                } else if (event.button === 2) { // Right click
                    isRightMouseDown = true;
                }
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onMouseMove(event) {
                if (!isMouseDown && !isRightMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                if (isMouseDown) {
                    // Rotate camera around target
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                    
                    const radius = camera.position.distanceTo(new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z));
                    camera.position.x = targetPosition.x + radius * Math.cos(targetRotationX) * Math.sin(targetRotationY);
                    camera.position.y = targetPosition.y + radius * Math.sin(targetRotationX);
                    camera.position.z = targetPosition.z + radius * Math.cos(targetRotationX) * Math.cos(targetRotationY);
                    camera.lookAt(targetPosition.x, targetPosition.y, targetPosition.z);
                }
                
                if (isRightMouseDown) {
                    // Pan camera
                    const factor = 0.1;
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.getWorldDirection(new THREE.Vector3());
                    right.crossVectors(camera.up, new THREE.Vector3().subVectors(targetPosition, camera.position).normalize());
                    up.copy(camera.up);
                    
                    targetPosition.x += right.x * deltaX * factor + up.x * deltaY * factor;
                    targetPosition.y += right.y * deltaX * factor + up.y * deltaY * factor;
                    targetPosition.z += right.z * deltaX * factor + up.z * deltaY * factor;
                    
                    camera.position.x += right.x * deltaX * factor + up.x * deltaY * factor;
                    camera.position.y += right.y * deltaX * factor + up.y * deltaY * factor;
                    camera.position.z += right.z * deltaX * factor + up.z * deltaY * factor;
                    
                    camera.lookAt(targetPosition.x, targetPosition.y, targetPosition.z);
                }
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onMouseUp() {
                isMouseDown = false;
                isRightMouseDown = false;
            }
            
            function onMouseWheel(event) {
                const factor = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(factor);
                camera.lookAt(targetPosition.x, targetPosition.y, targetPosition.z);
            }
        }
        
        function onKeyDown(event) {
            if (event.key.toLowerCase() === 'r') {
                resetCamera();
            }
        }
        
        function resetCamera() {
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
        }
        
        // STL Loader
        function loadSTL(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const arrayBuffer = event.target.result;
                try {
                    const geometry = parseSTL(arrayBuffer);
                    displaySTL(geometry, file.name);
                } catch (error) {
                    document.getElementById('status').textContent = 'Error loading STL: ' + error.message;
                    console.error('STL loading error:', error);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Simple STL parser
        function parseSTL(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            
            // Check if binary STL
            if (arrayBuffer.byteLength < 84) {
                throw new Error('File too small to be a valid STL');
            }
            
            // Try to detect if it's ASCII STL
            const header = new TextDecoder().decode(new Uint8Array(arrayBuffer, 0, Math.min(80, arrayBuffer.byteLength)));
            if (header.toLowerCase().includes('solid')) {
                // Might be ASCII STL
                const text = new TextDecoder().decode(new Uint8Array(arrayBuffer));
                if (text.includes('facet normal')) {
                    return parseASCIISTL(text);
                }
            }
            
            // Parse as binary STL
            return parseBinarySTL(view);
        }
        
        function parseBinarySTL(view) {
            const triangles = view.getUint32(80, true);
            const geometry = new THREE.BufferGeometry();
            
            const vertices = [];
            const normals = [];
            
            let offset = 84;
            for (let i = 0; i < triangles; i++) {
                // Normal vector
                const nx = view.getFloat32(offset, true);
                const ny = view.getFloat32(offset + 4, true);
                const nz = view.getFloat32(offset + 8, true);
                offset += 12;
                
                // Vertices
                for (let j = 0; j < 3; j++) {
                    const x = view.getFloat32(offset, true);
                    const y = view.getFloat32(offset + 4, true);
                    const z = view.getFloat32(offset + 8, true);
                    offset += 12;
                    
                    vertices.push(x, y, z);
                    normals.push(nx, ny, nz);
                }
                
                offset += 2; // Skip attribute byte count
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            
            return geometry;
        }
        
        function parseASCIISTL(text) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            
            const lines = text.split('\n');
            let currentNormal = [0, 0, 0];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('facet normal')) {
                    const parts = line.split(/\s+/);
                    currentNormal = [
                        parseFloat(parts[2]),
                        parseFloat(parts[3]),
                        parseFloat(parts[4])
                    ];
                } else if (line.startsWith('vertex')) {
                    const parts = line.split(/\s+/);
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                    normals.push(...currentNormal);
                }
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            
            return geometry;
        }
        
        function displaySTL(geometry, filename) {
            // Remove existing mesh
            if (currentMesh) {
                scene.remove(currentMesh);
            }
            
            // Center and scale geometry
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 50 / maxDim;
            
            geometry.translate(-center.x, -center.y, -center.z);
            geometry.scale(scale, scale, scale);
            
            // Create material and mesh
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x00aaff,
                side: THREE.DoubleSide
            });
            
            currentMesh = new THREE.Mesh(geometry, material);
            currentMesh.castShadow = true;
            currentMesh.receiveShadow = true;
            scene.add(currentMesh);
            
            // Reset camera
            resetCamera();
            
            // Update status
            const vertices = geometry.attributes.position.count;
            const triangles = vertices / 3;
            document.getElementById('status').innerHTML = 
                `<strong>${filename}</strong><br>` +
                `Triangles: ${triangles.toLocaleString()}<br>` +
                `Vertices: ${vertices.toLocaleString()}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('status').textContent = 'Loading...';
                loadSTL(file);
            }
        });
        
        // Initialize the application
        init();
    </script>
</body>
</html>
